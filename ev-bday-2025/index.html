<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="robots" content="noindex, nofollow">
    <title>EVAN BDAY</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="A fun birthday adventure game with blocks, balloons, and surprises!">
    <meta name="theme-color" content="#228B22">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EVAN BDAY">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: 'Courier New', monospace;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 40%, #228B22 100%);
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevent scrolling/zooming */
        }

        /* Touch Controls - Now invisible zones */
        .touch-controls {
            display: none !important; /* Completely hide old controls */
        }

        .touch-button {
            display: none !important; /* Hide old buttons */
        }

        /* Invisible touch zones */
        .touch-zone {
            position: fixed;
            bottom: 0;
            width: 33.33vw;
            height: 160px;
            pointer-events: all;
            z-index: 1000;
            /* Invisible - no background or borders */
        }

        .touch-zone-left {
            left: 0;
        }

        .touch-zone-center {
            left: 33.33vw;
        }

        .touch-zone-right {
            right: 0;
        }

        /* Hide touch zones on desktop */
        @media (min-width: 768px) and (pointer: fine) {
            .touch-zone {
                display: none;
            }
        }


    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Invisible Touch Zones for Mobile -->
    <div class="touch-zone touch-zone-left" id="touchLeft"></div>
    <div class="touch-zone touch-zone-center" id="touchCenter"></div>
    <div class="touch-zone touch-zone-right" id="touchRight"></div>

    <script>
        // Game constants
        const BLOCK_SIZE = 20;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -15;
        const PLAYER_SPEED = 5;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full viewport size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Menu screen constants
        const MENU_SCREENS = {
            MAIN: 'main',
            OPTIONS: 'options', 
            HIGH_SCORES: 'high_scores',
            RSVP: 'rsvp',
            CONTROLS: 'controls',
            INSTALL: 'install',
            CREDITS: 'credits'
        };

        // Game state
        let keys = {};
        let gameStarted = false;
        let showingMenu = true;
        let currentMenuScreen = MENU_SCREENS.MAIN;
        let selectedMenuItem = 0; // Start on first item
        let lastKeyPress = 0;
        
        // Detect mobile device
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.innerWidth <= 768 && 'ontouchstart' in window);

        // Menu content for each screen
        const menuContent = {
            [MENU_SCREENS.MAIN]: {
                title: "EVAN BDAY 2025",
                items: [
                    { text: "NEW GAME", selectable: true, action: 'startGame' },
                    { text: "HIGH SCORES", selectable: true, action: 'showHighScores' },
                    { text: "OPTIONS", selectable: true, action: 'showOptions' },
                    { text: "RSVP", selectable: true, action: 'showRSVP' },
                    { text: "CONTROLS", selectable: true, action: 'showControls' },
                    { text: "INSTALL", selectable: true, action: 'showInstall' },
                    { text: "CREDITS", selectable: true, action: 'showCredits' }
                ]
            },
            [MENU_SCREENS.HIGH_SCORES]: {
                title: "HIGH SCORES", 
                items: [
                    { text: "GAMES PLAYED: 0", selectable: false },
                    { text: "PINATAS EXPLODED: 0", selectable: false },
                    { text: "BALLOONS LAUNCHED: 0", selectable: false },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            },
            [MENU_SCREENS.OPTIONS]: {
                title: "OPTIONS",
                items: [
                    { text: "SOUND: ON", selectable: true, action: 'toggleSound' },
                    { text: "MUSIC: ON", selectable: true, action: 'toggleMusic' },
                    { text: "", selectable: false },
                    { text: "CLEAR SCORES", selectable: true, action: 'clearScores' },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            },
            [MENU_SCREENS.RSVP]: {
                title: "RSVP",
                items: [
                    { text: "SATURDAY OCTOBER 25", selectable: false },
                    { text: "WILSHIRE PARK 1-3PM", selectable: false },
                    { text: "", selectable: false },
                    { text: "rsvp: jacobsonlaura@gmail.com", selectable: false },
                    { text: "", selectable: false },
                    { text: "BALLOONS JUICE PINATA", selectable: false },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            },
            [MENU_SCREENS.CONTROLS]: {
                title: "CONTROLS",
                items: [
                    { text: isMobile ? "TOUCH CONTROLS:" : "KEYBOARD CONTROLS:", selectable: false },
                    { text: "", selectable: false },
                    { text: isMobile ? "LEFT THIRD OF SCREEN" : "LEFT ARROW KEY", selectable: false },
                    { text: isMobile ? "(BOTTOM AREA) = MOVE LEFT" : "= MOVE LEFT", selectable: false },
                    { text: "", selectable: false },
                    { text: isMobile ? "CENTER THIRD OF SCREEN" : "SPACE KEY", selectable: false },
                    { text: isMobile ? "(BOTTOM AREA) = JUMP" : "= JUMP", selectable: false },
                    { text: "", selectable: false },
                    { text: isMobile ? "RIGHT THIRD OF SCREEN" : "RIGHT ARROW KEY", selectable: false },
                    { text: isMobile ? "(BOTTOM AREA) = MOVE RIGHT" : "= MOVE RIGHT", selectable: false },
                    { text: "", selectable: false },
                    { text: "GAME OBJECTIVES:", selectable: false },
                    { text: "HIT THE PINATA 5 TIMES", selectable: false },
                    { text: "TO MAKE IT EXPLODE!", selectable: false },
                    { text: "", selectable: false },
                    { text: "CATCH BALLOON ANIMALS", selectable: false },
                    { text: "TO FLOAT AROUND!", selectable: false },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            },
            [MENU_SCREENS.INSTALL]: {
                title: "INSTALL",
                items: [
                    { text: isMobile ? "ADD TO HOME SCREEN:" : "INSTALL THIS APP:", selectable: false },
                    { text: "", selectable: false },
                    { text: isMobile ? "1. TAP SHARE BUTTON" : "1. CLICK INSTALL BUTTON", selectable: false },
                    { text: isMobile ? "2. TAP 'ADD TO HOME SCREEN'" : "2. OR BOOKMARK THIS PAGE", selectable: false },
                    { text: isMobile ? "3. TAP 'ADD'" : "3. OPEN FROM BOOKMARK", selectable: false },
                    { text: "", selectable: false },
                    { text: "PLAY ANYTIME OFFLINE!", selectable: false },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            },
            [MENU_SCREENS.CREDITS]: {
                title: "CREDITS",
                items: [
                    { text: "https://wcm.is/ev-bday-2025", selectable: false },
                    { text: "", selectable: false },
                    { text: "[QR CODE]", selectable: false },
                    { text: "", selectable: false },
                    { text: "ESC - BACK", selectable: true, action: 'goBack' }
                ]
            }
        };

        // Statistics system using localStorage  
        const STATS_KEY = 'evan-bday-2025-stats';
        let gameStats = {
            gamesPlayed: 0,
            pinatasExploded: 0,
            balloonsLaunched: 0
        };

        // Load stats from localStorage
        function loadStats() {
            try {
                const savedStats = localStorage.getItem(STATS_KEY);
                if (savedStats) {
                    gameStats = { ...gameStats, ...JSON.parse(savedStats) };
                }
            } catch (error) {
                console.log('Error loading stats:', error);
            }
            updateHighScoresDisplay();
        }

        // Save stats to localStorage
        function saveStats() {
            try {
                localStorage.setItem(STATS_KEY, JSON.stringify(gameStats));
            } catch (error) {
                console.log('Error saving stats:', error);
            }
        }

        // Update the high scores display with current stats
        function updateHighScoresDisplay() {
            const highScoresContent = menuContent[MENU_SCREENS.HIGH_SCORES];
            highScoresContent.items[0].text = `GAMES PLAYED: ${gameStats.gamesPlayed}`;
            highScoresContent.items[1].text = `PINATAS EXPLODED: ${gameStats.pinatasExploded}`;
            highScoresContent.items[2].text = `BALLOONS LAUNCHED: ${gameStats.balloonsLaunched}`;
        }

        // Increment specific stats
        function incrementGamesPlayed() {
            gameStats.gamesPlayed++;
            saveStats();
            updateHighScoresDisplay();
        }

        function incrementPinatasExploded() {
            gameStats.pinatasExploded++;
            saveStats();
            updateHighScoresDisplay();
        }

        function incrementBalloonsLaunched() {
            gameStats.balloonsLaunched++;
            saveStats();
            updateHighScoresDisplay();
        }

        // Clear all statistics
        function clearStats() {
            gameStats = {
                gamesPlayed: 0,
                pinatasExploded: 0,
                balloonsLaunched: 0
            };
            saveStats();
            updateHighScoresDisplay();
        }
        
        // Block types
        const BLOCK_TYPES = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            BIRTHDAY_BLOCK: 4,
            CAKE_BLOCK: 5,
            PARTY_BLOCK: 6,
            TREE_TRUNK: 7,
            TREE_LEAVES: 8,
            PINATA: 9,
            BALLOON: 10,
            BALLOON_ARTIST: 11,
            BALLOON_ANIMAL: 12,
            TABLE: 13,
            JUICE_BOX: 14
        };

        // Block colors with gradients
        const BLOCK_COLORS = {
            [BLOCK_TYPES.GRASS]: { 
                top: '#90EE90', 
                bottom: '#228B22',
                accent: '#32CD32'
            },
            [BLOCK_TYPES.DIRT]: { 
                top: '#CD853F', 
                bottom: '#5D4037',
                accent: '#8B4513'
            },
            [BLOCK_TYPES.STONE]: { 
                top: '#C0C0C0', 
                bottom: '#505050',
                accent: '#808080'
            },
            [BLOCK_TYPES.BIRTHDAY_BLOCK]: { 
                top: '#FFB6C1', 
                bottom: '#FF1493',
                accent: '#FF69B4'
            },
            [BLOCK_TYPES.CAKE_BLOCK]: { 
                top: '#FFF8DC', 
                bottom: '#F0E68C',
                accent: '#FFB6C1'
            },
            [BLOCK_TYPES.PARTY_BLOCK]: { 
                top: '#FF6347', 
                bottom: '#DC143C',
                accent: '#FF1493'
            },
            [BLOCK_TYPES.TREE_TRUNK]: { 
                top: '#8B4513', 
                bottom: '#5D4037',
                accent: '#A0522D'
            },
            [BLOCK_TYPES.TREE_LEAVES]: { 
                top: '#90EE90', 
                bottom: '#228B22',
                accent: '#32CD32'
            },
            [BLOCK_TYPES.PINATA]: { 
                top: '#FFD700', 
                bottom: '#FF4500',
                accent: '#FF6347'
            },
            [BLOCK_TYPES.BALLOON]: { 
                top: '#FF69B4', 
                bottom: '#DC143C',
                accent: '#FF1493'
            },
            [BLOCK_TYPES.BALLOON_ARTIST]: { 
                top: '#FFE4B5', 
                bottom: '#DEB887',
                accent: '#F4A460'
            },
            [BLOCK_TYPES.BALLOON_ANIMAL]: { 
                top: '#87CEEB', 
                bottom: '#4682B4',
                accent: '#6495ED'
            },
            [BLOCK_TYPES.TABLE]: { 
                top: '#D2B48C', 
                bottom: '#8B7355',
                accent: '#A0522D'
            },
            [BLOCK_TYPES.JUICE_BOX]: { 
                top: '#FF6347', 
                bottom: '#DC143C',
                accent: '#FFD700'
            }
        };

        // Player object (positioned relative to screen size)
        const player = {
            x: 200, // Moved away from tree area
            y: 0,   // Will be set properly after level is created
            width: 18,
            height: 24,
            velX: 0,
            velY: 0,
            onGround: false,
            color: '#4169E1',
            jumpParticles: [],
            lastPinataHit: 0, // Track timing to prevent multiple hits per jump
            attachedBalloon: null, // Reference to balloon animal player is hanging from
            balloonOffset: { x: 0, y: 0 } // Offset from balloon center
        };

        // Rainbow explosion particles
        let rainbowParticles = [];
        
        // Balloon animal system
        let balloonAnimals = [];
        let lastBalloonTime = 0;
        let balloonArtistPosition = null;
        let pinataReplacementTime = 0; // Time when replacement should happen
        let pinataReplacementDelay = 5000; // 5 second delay before replacement
        
        // Party kids system
        let partyKids = [];
        
        // Pinata shake animation
        let pinataShake = {
            shaking: false,
            shakeTime: 0,
            shakeIntensity: 0
        };

        // Particle system for jump effects
        function addJumpParticles() {
            for (let i = 0; i < 5; i++) {
                player.jumpParticles.push({
                    x: player.x + player.width / 2 + (Math.random() - 0.5) * 20,
                    y: player.y + player.height,
                    velX: (Math.random() - 0.5) * 6,
                    velY: Math.random() * -3,
                    life: 20,
                    maxLife: 20
                });
            }
        }

        function updateParticles() {
            for (let i = player.jumpParticles.length - 1; i >= 0; i--) {
                const particle = player.jumpParticles[i];
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velY += 0.2; // gravity
                particle.life--;

                if (particle.life <= 0) {
                    player.jumpParticles.splice(i, 1);
                }
            }
        }

        // Level data - will be populated with birthday message
        let level = [];
        const LEVEL_WIDTH = Math.ceil(window.innerWidth / BLOCK_SIZE);
        const LEVEL_HEIGHT = Math.ceil(window.innerHeight / BLOCK_SIZE);

        // Letter patterns (5x4 blocks each)
        const LETTERS = {
            'H': [
                [1,0,0,1],
                [1,0,0,1],
                [1,1,1,1],
                [1,0,0,1],
                [1,0,0,1]
            ],
            'A': [
                [0,1,1,0],
                [1,0,0,1],
                [1,1,1,1],
                [1,0,0,1],
                [1,0,0,1]
            ],
            'P': [
                [1,1,1,0],
                [1,0,0,1],
                [1,1,1,0],
                [1,0,0,0],
                [1,0,0,0]
            ],
            'Y': [
                [1,0,0,1],
                [1,0,0,1],
                [0,1,1,0],
                [0,1,0,0],
                [0,1,0,0]
            ],
            'B': [
                [1,1,1,0],
                [1,0,0,1],
                [1,1,1,0],
                [1,0,0,1],
                [1,1,1,0]
            ],
            'I': [
                [1,1,1],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [1,1,1]
            ],
            'R': [
                [1,1,1,0],
                [1,0,0,1],
                [1,1,1,0],
                [1,0,1,0],
                [1,0,0,1]
            ],
            'T': [
                [1,1,1],
                [0,1,0],
                [0,1,0],
                [0,1,0],
                [0,1,0]
            ],
            'D': [
                [1,1,1,0],
                [1,0,0,1],
                [1,0,0,1],
                [1,0,0,1],
                [1,1,1,0]
            ],
            'E': [
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,0],
                [1,0,0,0],
                [1,1,1,1]
            ],
            'V': [
                [1,0,0,1],
                [1,0,0,1],
                [1,0,0,1],
                [0,1,1,0],
                [0,1,1,0]
            ],
            'N': [
                [1,0,0,1],
                [1,1,0,1],
                [1,0,1,1],
                [1,0,0,1],
                [1,0,0,1]
            ],
            '2': [
                [1,1,1,1],
                [0,0,0,1],
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,1]
            ],
            '0': [
                [1,1,1,1],
                [1,0,0,1],
                [1,0,0,1],
                [1,0,0,1],
                [1,1,1,1]
            ],
            '5': [
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,1],
                [0,0,0,1],
                [1,1,1,1]
            ]
        };

        // Initialize empty level
        function initLevel() {
            level = [];
            for (let y = 0; y < LEVEL_HEIGHT; y++) {
                level[y] = [];
                for (let x = 0; x < LEVEL_WIDTH; x++) {
                    level[y][x] = BLOCK_TYPES.AIR;
                }
            }
            
            // Create ground
            for (let x = 0; x < LEVEL_WIDTH; x++) {
                level[LEVEL_HEIGHT - 1][x] = BLOCK_TYPES.GRASS;
                level[LEVEL_HEIGHT - 2][x] = BLOCK_TYPES.DIRT;
                level[LEVEL_HEIGHT - 3][x] = BLOCK_TYPES.DIRT;
            }

            // Create birthday message
            createBirthdayMessage();
            
            // Add birthday presents
            addBirthdayPresents();
        }

        // Create the birthday message in blocks (vertical layout)
        function createBirthdayMessage() {
            const words = ["EVAN", "BDAY", "2025"];
            let currentY = 5;
            
            words.forEach((word, wordIndex) => {
                const wordWidth = calculateWordWidth(word);
                const startX = Math.floor((LEVEL_WIDTH - wordWidth) / 2);
                
                let currentX = startX;
                word.split('').forEach((letter, letterIndex) => {
                    if (LETTERS[letter]) {
                        placeLetter(letter, currentX, currentY);
                        currentX += LETTERS[letter][0].length + 1;
                    }
                });
                
                currentY += 8; // Space between words vertically
            });

            addDecorations();
        }
        
        // Calculate total width needed for a word
        function calculateWordWidth(word) {
            let width = 0;
            word.split('').forEach((letter) => {
                if (LETTERS[letter]) {
                    width += LETTERS[letter][0].length + 1;
                }
            });
            return width - 1; // Remove last space
        }

        // Place a letter at given position
        function placeLetter(letter, startX, startY) {
            const pattern = LETTERS[letter];
            const colors = [BLOCK_TYPES.BIRTHDAY_BLOCK, BLOCK_TYPES.CAKE_BLOCK, BLOCK_TYPES.PARTY_BLOCK];
            const letterColor = colors[Math.floor(Math.random() * colors.length)];

            for (let y = 0; y < pattern.length; y++) {
                for (let x = 0; x < pattern[y].length; x++) {
                    if (pattern[y][x] === 1) {
                        const levelX = startX + x;
                        const levelY = startY + y;
                        if (levelX < LEVEL_WIDTH && levelY < LEVEL_HEIGHT) {
                            level[levelY][levelX] = letterColor;
                        }
                    }
                }
            }
        }

        // Add decorative elements
        function addDecorations() {
            // Removed floating platforms that looked like clouds

            // Add balloons at jumpable heights
            if (LEVEL_WIDTH > 15) {
                // More balloons at various heights for platforming
                for (let i = 0; i < 12; i++) {
                    const x = Math.floor(Math.random() * (LEVEL_WIDTH - 4)) + 2;
                    const y = Math.floor(Math.random() * 8) + 4; // Lower in scene (y 4-11)
                    if (level[y] && level[y][x] === BLOCK_TYPES.AIR) {
                        level[y][x] = BLOCK_TYPES.BALLOON;
                    }
                }
                
                // Add some balloon clusters for easier jumping
                for (let cluster = 0; cluster < 3; cluster++) {
                    const centerX = Math.floor(Math.random() * (LEVEL_WIDTH - 8)) + 4;
                    const centerY = Math.floor(Math.random() * 4) + 6; // Mid-height
                    
                    // Create balloon clusters (2x2 or 3x1)
                    for (let dx = 0; dx < 3; dx++) {
                        const balloonX = centerX + dx;
                        const balloonY = centerY + (dx % 2); // Slight height variation
                        if (balloonX < LEVEL_WIDTH && balloonY < LEVEL_HEIGHT - 5 && 
                            level[balloonY] && level[balloonY][balloonX] === BLOCK_TYPES.AIR) {
                            level[balloonY][balloonX] = BLOCK_TYPES.BALLOON;
                        }
                    }
                }
            }

            // Add bigger tree on the left side
            if (LEVEL_WIDTH > 15 && LEVEL_HEIGHT > 15) {
                const treeX = 4;
                // Bigger tree trunk (2 blocks wide, taller)
                for (let y = LEVEL_HEIGHT - 8; y < LEVEL_HEIGHT - 1; y++) {
                    for (let x = treeX; x <= treeX + 1; x++) {
                        if (level[y] && level[y][x] !== undefined) {
                            level[y][x] = BLOCK_TYPES.TREE_TRUNK;
                        }
                    }
                }
                
                // Bigger tree crown (5x4 leaves)
                for (let dy = -3; dy <= 0; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const leafY = LEVEL_HEIGHT - 8 + dy;
                        const leafX = treeX + dx;
                        if (leafY >= 0 && leafY < LEVEL_HEIGHT && leafX >= 0 && leafX < LEVEL_WIDTH) {
                            if (level[leafY] && level[leafY][leafX] !== undefined) {
                                level[leafY][leafX] = BLOCK_TYPES.TREE_LEAVES;
                            }
                        }
                    }
                }
                
                // Create bigger pinata (2x2 blocks hanging from tree)
                createPinata(treeX + 3, LEVEL_HEIGHT - 10);
            }
        }
        
        // Create a bigger, more obvious pinata
        function createPinata(startX, startY) {
            // 2x2 pinata blocks
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const pinataY = startY + dy;
                    const pinataX = startX + dx;
                    if (pinataY >= 0 && pinataY < LEVEL_HEIGHT && pinataX >= 0 && pinataX < LEVEL_WIDTH) {
                        if (level[pinataY] && level[pinataY][pinataX] !== undefined) {
                            level[pinataY][pinataX] = BLOCK_TYPES.PINATA;
                        }
                    }
                }
            }
            
            // Store pinata position for hit detection
            window.pinataBlocks = [
                {x: startX, y: startY},
                {x: startX + 1, y: startY},
                {x: startX, y: startY + 1},
                {x: startX + 1, y: startY + 1}
            ];
            window.pinataHits = 0;
            window.pinataDestroyed = false;
        }
        
        // Add birthday presents and balloon artist
        function addBirthdayPresents() {
            if (LEVEL_WIDTH > 15) {
                // Add birthday presents at bottom right corner (smaller to make room for balloon artist)
                for (let y = LEVEL_HEIGHT - 4; y < LEVEL_HEIGHT - 1; y++) {
                    for (let x = LEVEL_WIDTH - 8; x < LEVEL_WIDTH - 5; x++) {
                        if (level[y] && level[y][x] !== undefined) {
                            level[y][x] = BLOCK_TYPES.CAKE_BLOCK;
                        }
                    }
                }
                
                // Add balloon artist character in the corner
                const artistX = LEVEL_WIDTH - 3;
                const artistY = LEVEL_HEIGHT - 4;
                if (level[artistY] && level[artistY][artistX] !== undefined) {
                    level[artistY][artistX] = BLOCK_TYPES.BALLOON_ARTIST;
                    balloonArtistPosition = {x: artistX, y: artistY};
                }
                
                // Add table with juice boxes in the middle-left area
                addJuiceTable();
                
                // Add party kids
                createPartyKids();
            }
        }

        // Add a table with juice boxes
        function addJuiceTable() {
            const tableX = Math.floor(LEVEL_WIDTH * 0.3); // 30% from left
            const tableY = LEVEL_HEIGHT - 4; // On ground level
            
            // Create table (3 blocks wide)
            for (let x = tableX; x < tableX + 3; x++) {
                if (level[tableY] && level[tableY][x] !== undefined) {
                    level[tableY][x] = BLOCK_TYPES.TABLE;
                }
            }
            
            // Add juice boxes on top of table
            for (let x = tableX; x < tableX + 3; x++) {
                if (level[tableY - 1] && level[tableY - 1][x] !== undefined) {
                    level[tableY - 1][x] = BLOCK_TYPES.JUICE_BOX;
                }
            }
        }

        // Create 12 party kids hanging out in a cluster
        function createPartyKids() {
            partyKids = [];
            
            const kidColors = [
                '#FF69B4', '#87CEEB', '#98FB98', '#FFB6C1', '#DDA0DD', '#F0E68C',
                '#FFA07A', '#20B2AA', '#DEB887', '#F5DEB3', '#CD853F', '#D2691E'
            ];
            
            // Create cluster center near the tree/pinata area (left side)
            const clusterCenterX = Math.floor(LEVEL_WIDTH * 0.2) * BLOCK_SIZE;
            const clusterCenterY = (LEVEL_HEIGHT - 4) * BLOCK_SIZE - 24;
            
            // Create kids and place them in a casual cluster
            for (let i = 0; i < 12; i++) {
                const kid = {
                    id: i,
                    width: 18,
                    height: 24,
                    color: kidColors[i],
                    state: 'hanging_out',
                    bobOffset: Math.random() * Math.PI * 2,
                    lastDirectionChange: Date.now() + Math.random() * 5000,
                    directionChangeInterval: 2000 + Math.random() * 4000,
                    direction: Math.random() < 0.5 ? 'left' : 'right',
                    chatBubbleTime: 0,
                    celebrating: false,
                    celebrationTime: 0,
                    jumpPhase: Math.random() * Math.PI * 2,
                    jumpHeight: 0
                };
                
                // Position kids in a loose cluster around the center
                const angle = (i / 12) * Math.PI * 2; // Spread around circle
                const radius = 30 + Math.random() * 40; // Vary distance from center
                kid.x = clusterCenterX + Math.cos(angle) * radius;
                kid.y = clusterCenterY + Math.sin(angle) * radius * 0.3; // Flatten vertically
                
                // Keep kids on ground level
                kid.y = clusterCenterY;
                
                partyKids.push(kid);
            }
        }

        // Make all kids celebrate (called when pinata breaks)
        function startKidsCelebration() {
            partyKids.forEach(kid => {
                kid.celebrating = true;
                kid.celebrationTime = 180; // 3 seconds at 60fps
                kid.jumpPhase = Math.random() * Math.PI * 2; // Randomize jump timing
                kid.chatBubbleTime = 90; // Show excited chat bubbles
            });
        }

        // Update party kids casual behavior
        function updatePartyKids() {
            if (partyKids.length === 0) return;
            
            const currentTime = Date.now();
            
            partyKids.forEach(kid => {
                // Handle celebration state
                if (kid.celebrating) {
                    kid.celebrationTime--;
                    if (kid.celebrationTime <= 0) {
                        kid.celebrating = false;
                        kid.jumpHeight = 0;
                    } else {
                        // Animate jumping
                        kid.jumpPhase += 0.3;
                        kid.jumpHeight = Math.sin(kid.jumpPhase) * 15; // Jump up to 15 pixels
                        if (kid.jumpHeight < 0) kid.jumpHeight = 0; // Only jump up, not down below ground
                    }
                } else {
                    // Normal behavior when not celebrating
                    // Randomly change direction kids are looking
                    if (currentTime - kid.lastDirectionChange > kid.directionChangeInterval) {
                        kid.direction = Math.random() < 0.5 ? 'left' : 'right';
                        kid.lastDirectionChange = currentTime;
                        kid.directionChangeInterval = 2000 + Math.random() * 4000; // 2-6 seconds
                    }
                    
                    // Sometimes show a chat bubble (simple animation)
                    if (Math.random() < 0.001) { // Very rare random chat
                        kid.chatBubbleTime = 60; // Show for 1 second at 60fps
                    }
                }
                
                if (kid.chatBubbleTime > 0) {
                    kid.chatBubbleTime--;
                }
            });
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (showingMenu) {
                handleMenuInput(e);
                e.preventDefault();
                return;
            }
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Get current menu data
        function getCurrentMenuData() {
            return menuContent[currentMenuScreen];
        }

        // Get selectable items for current screen
        function getSelectableItems() {
            const menuData = getCurrentMenuData();
            return menuData.items.map((item, index) => ({ index, item }))
                           .filter(({ item }) => item.selectable)
                           .map(({ index }) => index);
        }

        // Navigate to a new menu screen
        function navigateToScreen(screen) {
            currentMenuScreen = screen;
            selectedMenuItem = 0; // Reset selection
            
            // Find first selectable item
            const selectableItems = getSelectableItems();
            if (selectableItems.length > 0) {
                selectedMenuItem = selectableItems[0];
            }
        }

        // Handle menu navigation and selection
        function handleMenuInput(e) {
            const currentTime = Date.now();
            if (currentTime - lastKeyPress < 200) return; // Debounce
            lastKeyPress = currentTime;

            switch(e.code) {
                case 'ArrowUp':
                case 'ArrowLeft':
                    navigateMenuUp();
                    break;
                case 'ArrowDown':
                case 'ArrowRight':
                    navigateMenuDown();
                    break;
                case 'Space':
                case 'Enter':
                    selectMenuItem();
                    break;
                case 'Escape':
                    if (currentMenuScreen !== MENU_SCREENS.MAIN) {
                        navigateToScreen(MENU_SCREENS.MAIN);
                    }
                    break;
            }
        }

        function navigateMenuUp() {
            const selectableItems = getSelectableItems();
            const currentIndex = selectableItems.indexOf(selectedMenuItem);
            if (currentIndex > 0) {
                selectedMenuItem = selectableItems[currentIndex - 1];
            } else if (selectableItems.length > 0) {
                // Wrap to last item
                selectedMenuItem = selectableItems[selectableItems.length - 1];
            }
        }

        function navigateMenuDown() {
            const selectableItems = getSelectableItems();
            const currentIndex = selectableItems.indexOf(selectedMenuItem);
            if (currentIndex >= 0 && currentIndex < selectableItems.length - 1) {
                selectedMenuItem = selectableItems[currentIndex + 1];
            } else if (selectableItems.length > 0) {
                // Wrap to first item
                selectedMenuItem = selectableItems[0];
            }
        }

        function selectMenuItem() {
            const menuData = getCurrentMenuData();
            const selectedItem = menuData.items[selectedMenuItem];
            
            if (!selectedItem || !selectedItem.selectable) return;
            
            switch(selectedItem.action) {
                case 'startGame':
                    startNewGame();
                    break;
                case 'showHighScores':
                    navigateToScreen(MENU_SCREENS.HIGH_SCORES);
                    break;
                case 'showOptions':
                    navigateToScreen(MENU_SCREENS.OPTIONS);
                    break;
                case 'showRSVP':
                    navigateToScreen(MENU_SCREENS.RSVP);
                    break;
                case 'showControls':
                    navigateToScreen(MENU_SCREENS.CONTROLS);
                    break;
                case 'showInstall':
                    navigateToScreen(MENU_SCREENS.INSTALL);
                    break;
                case 'showCredits':
                    navigateToScreen(MENU_SCREENS.CREDITS);
                    break;
                case 'goBack':
                    navigateToScreen(MENU_SCREENS.MAIN);
                    break;
                case 'toggleSound':
                    // TODO: Implement sound toggle
                    break;
                case 'toggleMusic':
                    // TODO: Implement music toggle
                    break;
                case 'clearScores':
                    clearStats();
                    break;
            }
        }

        // Touch control state
        const touchState = {
            left: false,
            right: false,
            jump: false
        };

        // Touch event handlers for invisible zones
        function setupTouchControls() {
            const touchLeft = document.getElementById('touchLeft');
            const touchCenter = document.getElementById('touchCenter');
            const touchRight = document.getElementById('touchRight');

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => {
                if (e.target.classList.contains('touch-zone')) {
                    e.preventDefault();
                }
            });

            // Left Zone - Move Left
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.left = true;
                keys['ArrowLeft'] = true;
            });

            touchLeft.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchState.left = false;
                keys['ArrowLeft'] = false;
            });

            touchLeft.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchState.left = false;
                keys['ArrowLeft'] = false;
            });

            // Right Zone - Move Right
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.right = true;
                keys['ArrowRight'] = true;
            });

            touchRight.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchState.right = false;
                keys['ArrowRight'] = false;
            });

            touchRight.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchState.right = false;
                keys['ArrowRight'] = false;
            });

            // Center Zone - Jump
            touchCenter.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.jump = true;
                keys['Space'] = true;
            });

            touchCenter.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchState.jump = false;
                keys['Space'] = false;
            });

            touchCenter.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchState.jump = false;
                keys['Space'] = false;
            });
        }

        // Touch support for menu interaction
        document.addEventListener('touchstart', (e) => {
            if (showingMenu) {
                handleMenuTouch(e);
                e.preventDefault();
            }
        });

        function handleMenuTouch(e) {
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Convert to canvas coordinates
            const canvasX = touchX * (canvas.width / rect.width);
            const canvasY = touchY * (canvas.height / rect.height);
            
            // Get current menu data
            const menuData = getCurrentMenuData();
            const items = menuData.items;
            
            // Check if touch is on any menu item for direct selection
            const startY = canvas.height * 0.45; // Match drawPartyDetails positioning
            const lineHeight = 22;
            const titleHeight = lineHeight + 8;
            
            // Calculate item positions
            for (let index = 0; index < items.length; index++) {
                const itemY = startY + titleHeight + 8 + (index * lineHeight);
                
                // Check if touch is within this item's Y range
                if (canvasY >= itemY - 2 && canvasY <= itemY + lineHeight - 2) {
                    if (items[index].selectable) {
                        selectedMenuItem = index;
                        selectMenuItem(); // Auto-select when tapped
                        return;
                    }
                }
            }
            
            // Handle left/right navigation in bottom touch zones
            const windowHeight = window.innerHeight;
            const screenY = touch.clientY;
            
            // If touch is in bottom 160px
            if (screenY >= windowHeight - 160) {
                const windowWidth = window.innerWidth;
                const leftThird = windowWidth / 3;
                const rightThird = windowWidth * 2 / 3;
                
                if (touch.clientX < leftThird) {
                    // Left zone - go up in menu
                    navigateMenuUp();
                } else if (touch.clientX > rightThird) {
                    // Right zone - go down in menu  
                    navigateMenuDown();
                } else {
                    // Center zone - select current item
                    selectMenuItem();
                }
            }
        }

        function getMenuItemY(itemIndex) {
            const startY = canvas.height * 0.45; // Updated to match new menu position
            const lineHeight = 22;
            // NEW GAME is at index 8 in the details array
            return startY + (8 * lineHeight) + 8;
        }

        // Prevent zoom on mobile
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });

        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        });

        document.addEventListener('gestureend', (e) => {
            e.preventDefault();
        });

        // Collision detection
        function checkCollision(x, y, width, height) {
            const left = Math.floor(x / BLOCK_SIZE);
            const right = Math.floor((x + width - 1) / BLOCK_SIZE);
            const top = Math.floor(y / BLOCK_SIZE);
            const bottom = Math.floor((y + height - 1) / BLOCK_SIZE);

            for (let py = top; py <= bottom; py++) {
                for (let px = left; px <= right; px++) {
                    if (py >= 0 && py < LEVEL_HEIGHT && px >= 0 && px < LEVEL_WIDTH) {
                        if (level[py][px] !== BLOCK_TYPES.AIR && level[py][px] !== BLOCK_TYPES.PINATA) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Update player physics
        function updatePlayer() {
            // Check if player is attached to a balloon
            if (player.attachedBalloon) {
                // Player is floating with balloon
                handleBalloonFloating();
            } else {
                // Normal player physics
                handleNormalMovement();
            }

            // Update particles
            updateParticles();
            
            // Check for pinata collision
            checkPinataCollision();
            
            // Check for balloon animal collision
            checkBalloonAnimalCollision();
            
            // Update balloon animal system
            updateBalloonAnimals();
            
            // Update party kids
            updatePartyKids();
            
            // Update pinata shake animation
            updatePinataShake();
        }

        // Handle normal player movement (when not attached to balloon)
        function handleNormalMovement() {
            // Horizontal movement with acceleration
            if (keys['ArrowLeft']) {
                player.velX = Math.max(player.velX - 1, -PLAYER_SPEED);
            } else if (keys['ArrowRight']) {
                player.velX = Math.min(player.velX + 1, PLAYER_SPEED);
            } else {
                player.velX *= 0.85; // Friction
            }

            // Jumping with particle effects
            if (keys['Space'] && player.onGround) {
                player.velY = JUMP_FORCE;
                player.onGround = false;
                addJumpParticles();
            }

            // Apply gravity
            player.velY += GRAVITY;

            // Terminal velocity
            player.velY = Math.min(player.velY, 20);

            // Horizontal collision
            let newX = player.x + player.velX;
            if (!checkCollision(newX, player.y, player.width, player.height)) {
                player.x = newX;
            } else {
                player.velX = 0;
            }

            // Vertical collision
            let newY = player.y + player.velY;
            if (!checkCollision(player.x, newY, player.width, player.height)) {
                player.y = newY;
                player.onGround = false;
            } else {
                if (player.velY > 0) {
                    player.onGround = true;
                    // Landing particles
                    if (player.velY > 5) {
                        addJumpParticles();
                    }
                }
                player.velY = 0;
            }

            // Keep player in bounds
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        }

        // Handle player floating with balloon
        function handleBalloonFloating() {
            const balloon = player.attachedBalloon;
            
            // Check if balloon still exists
            if (!balloonAnimals.includes(balloon)) {
                player.attachedBalloon = null;
                player.balloonOffset = { x: 0, y: 0 };
                return;
            }

            // Check for jump/space to release balloon
            if (keys['Space']) {
                releaseBalloon();
                return;
            }

            // Limited horizontal movement while floating
            if (keys['ArrowLeft']) {
                balloon.velX = Math.max(balloon.velX - 0.15, -1); // Slower steering (was -0.3, -2)
            } else if (keys['ArrowRight']) {
                balloon.velX = Math.min(balloon.velX + 0.15, 1); // Slower steering (was +0.3, +2)
            }

            // Player follows balloon position
            const bobY = Math.sin((Date.now() * 0.003) + balloon.bobOffset) * 3;
            player.x = balloon.x + player.balloonOffset.x;
            player.y = balloon.y + bobY + player.balloonOffset.y;

            // Reset ground state when floating
            player.onGround = false;
            player.velX = 0;
            player.velY = 0;
        }

        // Release player from balloon
        function releaseBalloon() {
            if (player.attachedBalloon) {
                player.velY = JUMP_FORCE * 0.7; // Give a small upward boost
                player.attachedBalloon = null;
                player.balloonOffset = { x: 0, y: 0 };
                addJumpParticles();
            }
        }

        // Check if player collides with balloon animals
        function checkBalloonAnimalCollision() {
            if (player.attachedBalloon) return; // Already attached

            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            for (let balloon of balloonAnimals) {
                const balloonCenterX = balloon.x;
                const balloonCenterY = balloon.y;
                const distance = Math.sqrt(
                    Math.pow(playerCenterX - balloonCenterX, 2) + 
                    Math.pow(playerCenterY - balloonCenterY, 2)
                );

                // If player is close enough to balloon (within 20 pixels)
                if (distance < 20) {
                    // Attach player to balloon
                    player.attachedBalloon = balloon;
                    player.balloonOffset = {
                        x: playerCenterX - balloonCenterX,
                        y: playerCenterY - balloonCenterY + 15 // Hang below balloon
                    };
                    
                    // Add sparkle effect when catching balloon
                    for (let i = 0; i < 5; i++) {
                        player.jumpParticles.push({
                            x: playerCenterX + (Math.random() - 0.5) * 20,
                            y: playerCenterY + (Math.random() - 0.5) * 20,
                            velX: (Math.random() - 0.5) * 4,
                            velY: (Math.random() - 0.5) * 4,
                            life: 20,
                            maxLife: 20
                        });
                    }
                    break;
                }
            }
        }
        
        // Update pinata shake animation
        function updatePinataShake() {
            if (pinataShake.shaking) {
                pinataShake.shakeTime--;
                if (pinataShake.shakeTime <= 0) {
                    pinataShake.shaking = false;
                    pinataShake.shakeIntensity = 0;
                }
            }
        }

        // Check if player hits the pinata
        function checkPinataCollision() {
            if (!window.pinataBlocks || window.pinataDestroyed) return;
            
            const currentTime = Date.now();
            if (currentTime - player.lastPinataHit < 200) return; // Further reduced cooldown for better touch detection
            
            // Use pixel-perfect collision detection instead of grid-based
            const playerLeft = player.x;
            const playerRight = player.x + player.width;
            const playerTop = player.y;
            const playerBottom = player.y + player.height;
            
            // Check collision with any pinata block using pixel coordinates
            for (let pinataBlock of window.pinataBlocks) {
                const pinataLeft = pinataBlock.x * BLOCK_SIZE;
                const pinataRight = pinataLeft + BLOCK_SIZE;
                const pinataTop = pinataBlock.y * BLOCK_SIZE;
                const pinataBottom = pinataTop + BLOCK_SIZE;
                
                // Check if player rectangle overlaps with pinata rectangle
                if (playerRight > pinataLeft && playerLeft < pinataRight &&
                    playerBottom > pinataTop && playerTop < pinataBottom) {
                    
                    // Player touched the pinata!
                    window.pinataHits++;
                    player.lastPinataHit = currentTime;
                    
                    // Start pinata shake animation
                    pinataShake.shaking = true;
                    pinataShake.shakeTime = 30; // Shake for 30 frames (0.5 seconds)
                    pinataShake.shakeIntensity = Math.min(window.pinataHits * 2, 6); // Increase intensity with hits
                    
                    // Add hit effect particles
                    addPinataHitEffect(pinataBlock.x * BLOCK_SIZE + BLOCK_SIZE/2, 
                                     pinataBlock.y * BLOCK_SIZE + BLOCK_SIZE/2);
                    
                    if (window.pinataHits >= 5) {
                        explodePinata();
                    }
                    break;
                }
            }
        }

        // Add particles when pinata is hit
        function addPinataHitEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                rainbowParticles.push({
                    x: x,
                    y: y,
                    velX: (Math.random() - 0.5) * 4,
                    velY: Math.random() * -3 - 1,
                    color: ['#FF0000', '#FF8000', '#FFFF00', '#00FF00', '#0080FF', '#8000FF'][Math.floor(Math.random() * 6)],
                    life: 30,
                    maxLife: 30,
                    size: 3
                });
            }
        }

        // Explode the pinata with rainbow particles
        function explodePinata() {
            if (window.pinataDestroyed) return;
            
            window.pinataDestroyed = true;
            incrementPinatasExploded(); // Track that a pinata was exploded
            
            // Set timer for pinata replacement (5 second delay)
            pinataReplacementTime = Date.now() + pinataReplacementDelay;
            
            // Remove pinata blocks from level
            for (let pinataBlock of window.pinataBlocks) {
                if (level[pinataBlock.y] && level[pinataBlock.y][pinataBlock.x] !== undefined) {
                    level[pinataBlock.y][pinataBlock.x] = BLOCK_TYPES.AIR;
                }
            }
            
            // Start kids celebration!
            startKidsCelebration();
            
            // Create massive rainbow explosion
            const centerX = window.pinataBlocks[0].x * BLOCK_SIZE + BLOCK_SIZE;
            const centerY = window.pinataBlocks[0].y * BLOCK_SIZE + BLOCK_SIZE;
            
            for (let i = 0; i < 50; i++) {
                rainbowParticles.push({
                    x: centerX,
                    y: centerY,
                    velX: (Math.random() - 0.5) * 12,
                    velY: Math.random() * -8 - 2,
                    color: ['#FF0000', '#FF8000', '#FFFF00', '#00FF00', '#0080FF', '#8000FF'][Math.floor(Math.random() * 6)],
                    life: 80,
                    maxLife: 80,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Check if there's already a replacement balloon in progress
        function hasReplacementBalloonInProgress() {
            return balloonAnimals.some(balloon => balloon.isReplacement);
        }

        // Create replacement pinata from balloon animal
        function createReplacementPinata() {
            if (!balloonArtistPosition) return;
            
            let startX, startY;
            
            // Check if we have existing balloon animals to transform
            if (balloonAnimals.length > 0) {
                // Find a balloon animal to transform
                const transformBalloon = balloonAnimals[0]; // Use the first available balloon animal
                startX = transformBalloon.x;
                startY = transformBalloon.y;
                
                // Remove the original balloon
                const originalIndex = balloonAnimals.indexOf(transformBalloon);
                if (originalIndex !== -1) {
                    balloonAnimals.splice(originalIndex, 1);
                }
            } else {
                // No balloon animals available, create one from the balloon artist
                startX = balloonArtistPosition.x * BLOCK_SIZE;
                startY = balloonArtistPosition.y * BLOCK_SIZE;
            }
            
            // Create a special balloon that will float to the tree
            const replacementBalloon = {
                x: startX,
                y: startY,
                velX: 0,
                velY: 0,
                animal: '', // Change to gift box during transformation
                color: '#FFD700',
                life: 600, // 10 seconds to reach tree
                bobOffset: 0,
                isReplacement: true,
                targetX: (window.pinataBlocks ? window.pinataBlocks[0].x * BLOCK_SIZE : 7 * BLOCK_SIZE),
                targetY: (window.pinataBlocks ? window.pinataBlocks[0].y * BLOCK_SIZE : (LEVEL_HEIGHT - 10) * BLOCK_SIZE),
                transformTimer: 0
            };
            
            balloonAnimals.push(replacementBalloon);
        }

        // Update rainbow particles
        function updateRainbowParticles() {
            for (let i = rainbowParticles.length - 1; i >= 0; i--) {
                const particle = rainbowParticles[i];
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velY += 0.3; // gravity
                particle.life--;

                if (particle.life <= 0) {
                    rainbowParticles.splice(i, 1);
                }
            }
        }

        // Update balloon animal system
        function updateBalloonAnimals() {
            const currentTime = Date.now();
            
            // Check if we need to create a replacement pinata (with delay)
            if (balloonArtistPosition && window.pinataDestroyed && !hasReplacementBalloonInProgress()) {
                // Only create replacement if enough time has passed
                if (pinataReplacementTime > 0 && currentTime >= pinataReplacementTime) {
                    createReplacementPinata();
                    pinataReplacementTime = 0; // Reset the timer
                }
            }
            
            // Create new balloon animal every 20-30 seconds
            if (balloonArtistPosition && currentTime - lastBalloonTime > (20000 + Math.random() * 10000)) {
                createBalloonAnimal();
                lastBalloonTime = currentTime;
            }
            
            // Update existing balloon animals
            for (let i = balloonAnimals.length - 1; i >= 0; i--) {
                const animal = balloonAnimals[i];
                
                if (animal.isReplacement) {
                    // Handle replacement balloon movement to tree
                    const dx = animal.targetX - animal.x;
                    const dy = animal.targetY - animal.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        // Move towards target
                        animal.velX = (dx / distance) * 2;
                        animal.velY = (dy / distance) * 2;
                        animal.x += animal.velX;
                        animal.y += animal.velY;
                        animal.transformTimer++;
                    } else {
                        // Reached target - transform into pinata!
                        transformToNewPinata(animal.targetX / BLOCK_SIZE, animal.targetY / BLOCK_SIZE);
                        balloonAnimals.splice(i, 1);
                        continue;
                    }
                } else {
                    // Normal balloon animal behavior
                    animal.x += animal.velX;
                    animal.y += animal.velY;
                }
                
                animal.life--;
                
                // Remove if off screen or life expired (but not replacement balloons)
                if (!animal.isReplacement && (animal.x < -50 || animal.x > canvas.width + 50 || 
                    animal.y < -50 || animal.life <= 0)) {
                    balloonAnimals.splice(i, 1);
                }
            }
        }

        // Transform the balloon into a new pinata at the target location
        function transformToNewPinata(gridX, gridY) {
            // Reset pinata state
            window.pinataHits = 0;
            window.pinataDestroyed = false;
            
            // Create new pinata at the tree location (2x2 blocks)
            const startX = Math.floor(gridX);
            const startY = Math.floor(gridY);
            
            // Add sparkle effect for transformation
            for (let i = 0; i < 15; i++) {
                rainbowParticles.push({
                    x: gridX * BLOCK_SIZE,
                    y: gridY * BLOCK_SIZE,
                    velX: (Math.random() - 0.5) * 8,
                    velY: Math.random() * -6 - 2,
                    color: '#FFD700',
                    life: 60,
                    maxLife: 60,
                    size: Math.random() * 3 + 2
                });
            }
            
            // Create the new pinata blocks
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const pinataY = startY + dy;
                    const pinataX = startX + dx;
                    if (pinataY >= 0 && pinataY < LEVEL_HEIGHT && pinataX >= 0 && pinataX < LEVEL_WIDTH) {
                        if (level[pinataY] && level[pinataY][pinataX] !== undefined) {
                            level[pinataY][pinataX] = BLOCK_TYPES.PINATA;
                        }
                    }
                }
            }
            
            // Update pinata blocks reference
            window.pinataBlocks = [
                {x: startX, y: startY},
                {x: startX + 1, y: startY},
                {x: startX, y: startY + 1},
                {x: startX + 1, y: startY + 1}
            ];
        }

        // Create a balloon animal from the balloon artist
        function createBalloonAnimal() {
            if (!balloonArtistPosition) return;
            
            const animals = ['', '', '', '', '', ''];
            const colors = ['#FF69B4', '#87CEEB', '#98FB98', '#FFB6C1', '#DDA0DD', '#F0E68C'];
            
            incrementBalloonsLaunched(); // Track that a balloon was launched
            
            balloonAnimals.push({
                x: balloonArtistPosition.x * BLOCK_SIZE,
                y: balloonArtistPosition.y * BLOCK_SIZE,
                velX: Math.random() * 0.8 - 0.4, // Slower horizontal drift (was 2, now 0.8)
                velY: -0.2 - Math.random() * 0.2, // Slower upward float (was -0.5 to -1.0, now -0.2 to -0.4)
                animal: animals[Math.floor(Math.random() * animals.length)],
                color: colors[Math.floor(Math.random() * colors.length)],
                life: 1200, // 20 seconds at 60fps
                bobOffset: Math.random() * Math.PI * 2 // For floating animation
            });
        }

        // Draw a block with Minecraft-style 3D effect
        function drawBlock(x, y, blockType) {
            const colors = BLOCK_COLORS[blockType];
            let blockX = x * BLOCK_SIZE;
            let blockY = y * BLOCK_SIZE;

            // Apply pinata shake effect
            if (blockType === BLOCK_TYPES.PINATA && pinataShake.shaking) {
                const shakeX = (Math.random() - 0.5) * pinataShake.shakeIntensity;
                const shakeY = (Math.random() - 0.5) * pinataShake.shakeIntensity;
                blockX += shakeX;
                blockY += shakeY;
            }

            // Create gradient
            const gradient = ctx.createLinearGradient(blockX, blockY, blockX, blockY + BLOCK_SIZE);
            gradient.addColorStop(0, colors.top);
            gradient.addColorStop(1, colors.bottom);

            // Fill block with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);

            // Add highlight (top and left edges)
            ctx.strokeStyle = colors.top;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(blockX, blockY + BLOCK_SIZE);
            ctx.lineTo(blockX, blockY);
            ctx.lineTo(blockX + BLOCK_SIZE, blockY);
            ctx.stroke();

            // Add shadow (bottom and right edges)
            ctx.strokeStyle = colors.bottom;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(blockX, blockY + BLOCK_SIZE);
            ctx.lineTo(blockX + BLOCK_SIZE, blockY + BLOCK_SIZE);
            ctx.lineTo(blockX + BLOCK_SIZE, blockY);
            ctx.stroke();

            // Add texture dots for certain blocks
            if (blockType === BLOCK_TYPES.GRASS || blockType === BLOCK_TYPES.DIRT) {
                ctx.fillStyle = colors.accent;
                for (let i = 0; i < 3; i++) {
                    const dotX = blockX + 6 + i * 8;
                    const dotY = blockY + 8 + (i % 2) * 8;
                    ctx.fillRect(dotX, dotY, 2, 2);
                }
            }

            // Add cake decorations
            if (blockType === BLOCK_TYPES.CAKE_BLOCK) {
                // Cherry on top
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(blockX + 14, blockY + 4, 4, 4);
                // Candle
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(blockX + 15, blockY + 2, 2, 6);
            }

            // Add party sparkles
            if (blockType === BLOCK_TYPES.PARTY_BLOCK) {
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(blockX + 6, blockY + 6, 2, 2);
                ctx.fillRect(blockX + 24, blockY + 12, 2, 2);
                ctx.fillRect(blockX + 12, blockY + 24, 2, 2);
                ctx.fillRect(blockX + 20, blockY + 8, 2, 2);
            }

            // Tree leaves details
            if (blockType === BLOCK_TYPES.TREE_LEAVES) {
                ctx.fillStyle = colors.accent;
                for (let i = 0; i < 4; i++) {
                    const dotX = blockX + 4 + (i % 2) * 12;
                    const dotY = blockY + 4 + Math.floor(i / 2) * 12;
                    ctx.fillRect(dotX, dotY, 3, 3);
                }
            }

            // Tree trunk wood grain
            if (blockType === BLOCK_TYPES.TREE_TRUNK) {
                ctx.fillStyle = colors.accent;
                ctx.fillRect(blockX + 4, blockY + 6, BLOCK_SIZE - 8, 2);
                ctx.fillRect(blockX + 6, blockY + 14, BLOCK_SIZE - 12, 2);
                ctx.fillRect(blockX + 3, blockY + 22, BLOCK_SIZE - 6, 2);
            }

            // Enhanced Pinata decorations with more vibrant rainbow colors
            if (blockType === BLOCK_TYPES.PINATA) {
                // More vibrant rainbow stripes covering the whole block
                ctx.fillStyle = '#FF0000'; // Red
                ctx.fillRect(blockX + 1, blockY + 2, BLOCK_SIZE - 2, 3);
                ctx.fillStyle = '#FF8000'; // Orange  
                ctx.fillRect(blockX + 1, blockY + 5, BLOCK_SIZE - 2, 3);
                ctx.fillStyle = '#FFFF00'; // Yellow
                ctx.fillRect(blockX + 1, blockY + 8, BLOCK_SIZE - 2, 3);
                ctx.fillStyle = '#00FF00'; // Green
                ctx.fillRect(blockX + 1, blockY + 11, BLOCK_SIZE - 2, 3);
                ctx.fillStyle = '#0080FF'; // Blue
                ctx.fillRect(blockX + 1, blockY + 14, BLOCK_SIZE - 2, 3);
                ctx.fillStyle = '#8000FF'; // Purple
                ctx.fillRect(blockX + 1, blockY + 17, BLOCK_SIZE - 2, 3);
                
                // Add sparkly accents
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(blockX + 3, blockY + 3, 2, 2);
                ctx.fillRect(blockX + BLOCK_SIZE - 5, blockY + 8, 2, 2);
                ctx.fillRect(blockX + 6, blockY + 15, 2, 2);
                
                // Hanging string (only draw if this is a top pinata block)
                if (window.pinataBlocks && window.pinataBlocks.length > 0) {
                    const topLeft = window.pinataBlocks[0];
                    if (x === topLeft.x && y === topLeft.y) {
                        // Apply shake to string too
                        let stringX = blockX + BLOCK_SIZE/2 - 1;
                        let stringY = blockY - 6;
                        if (pinataShake.shaking) {
                            stringX += (Math.random() - 0.5) * pinataShake.shakeIntensity * 0.5;
                        }
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(stringX, stringY, 2, 8);
                    }
                }
            }

            // Balloon string and shine
            if (blockType === BLOCK_TYPES.BALLOON) {
                // Balloon shine
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(blockX + 4, blockY + 4, 4, 4);
                // Balloon string
                ctx.fillStyle = '#000000';
                ctx.fillRect(blockX + BLOCK_SIZE/2 - 1, blockY + BLOCK_SIZE, 2, 8);
            }

            // Balloon artist character
            if (blockType === BLOCK_TYPES.BALLOON_ARTIST) {
                // Artist face
                ctx.fillStyle = '#FFE4B5';
                ctx.fillRect(blockX + 6, blockY + 4, 8, 6);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(blockX + 7, blockY + 5, 2, 2);
                ctx.fillRect(blockX + 11, blockY + 5, 2, 2);
                
                // Smile
                ctx.fillRect(blockX + 8, blockY + 8, 4, 1);
                
                // Hat
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(blockX + 4, blockY + 2, 12, 3);
                
                // Artist apron
                ctx.fillStyle = '#DEB887';
                ctx.fillRect(blockX + 5, blockY + 10, 10, 8);
                
                // Balloon in hand
                ctx.fillStyle = '#FF69B4';
                ctx.fillRect(blockX + 16, blockY + 8, 3, 4);
            }

            // Table with wood grain
            if (blockType === BLOCK_TYPES.TABLE) {
                // Table legs
                ctx.fillStyle = colors.bottom;
                ctx.fillRect(blockX + 2, blockY + 14, 3, 6);
                ctx.fillRect(blockX + 15, blockY + 14, 3, 6);
                
                // Wood grain lines
                ctx.fillStyle = colors.accent;
                ctx.fillRect(blockX + 4, blockY + 8, BLOCK_SIZE - 8, 1);
                ctx.fillRect(blockX + 6, blockY + 12, BLOCK_SIZE - 12, 1);
                ctx.fillRect(blockX + 3, blockY + 16, BLOCK_SIZE - 6, 1);
            }

            // Juice box with straw and label
            if (blockType === BLOCK_TYPES.JUICE_BOX) {
                // Juice box body
                ctx.fillStyle = colors.top;
                ctx.fillRect(blockX + 4, blockY + 6, 12, 14);
                
                // Juice box label
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(blockX + 6, blockY + 8, 8, 6);
                
                // "JUICE" text
                ctx.fillStyle = '#000';
                ctx.font = '6px monospace';
                ctx.fillText('JUICE', blockX + 7, blockY + 12);
                
                // Straw
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(blockX + 14, blockY + 2, 2, 8);
                
                // Straw bend
                ctx.fillRect(blockX + 16, blockY + 2, 2, 2);
            }

        }

        // Render everything
        function render() {
            // Clear canvas with animated sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.3, '#B0E0E6');
            skyGradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw clouds (scaled to screen)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const numClouds = Math.max(3, Math.floor(canvas.width / 300));
            for (let i = 0; i < numClouds; i++) {
                const cloudX = (i * (canvas.width / numClouds) + Date.now() * 0.01) % (canvas.width + 100) - 50;
                const cloudY = 30 + i * 20;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 15, 0, Math.PI * 2);
                ctx.arc(cloudX + 20, cloudY, 20, 0, Math.PI * 2);
                ctx.arc(cloudX + 40, cloudY, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            // No camera transform needed for full-screen layout
            ctx.save();

            // Draw blocks with enhanced graphics
            for (let y = 0; y < LEVEL_HEIGHT; y++) {
                for (let x = 0; x < LEVEL_WIDTH; x++) {
                    const blockType = level[y][x];
                    if (blockType !== BLOCK_TYPES.AIR) {
                        drawBlock(x, y, blockType);
                    }
                }
            }

            // Draw player with enhanced appearance
            const playerX = player.x;
            const playerY = player.y;

            // Player body gradient
            const playerGradient = ctx.createLinearGradient(playerX, playerY, playerX, playerY + player.height);
            playerGradient.addColorStop(0, '#6495ED');
            playerGradient.addColorStop(1, '#4169E1');
            ctx.fillStyle = playerGradient;
            ctx.fillRect(playerX, playerY, player.width, player.height);
            
            // Player outline
            ctx.strokeStyle = '#191970';
            ctx.lineWidth = 2;
            ctx.strokeRect(playerX, playerY, player.width, player.height);

            // Player face
            ctx.fillStyle = '#FFE4B5';
            ctx.fillRect(playerX + 2, playerY + 2, player.width - 4, 12);

            // Player eyes
            ctx.fillStyle = '#FFF';
            ctx.fillRect(playerX + 4, playerY + 4, 4, 4);
            ctx.fillRect(playerX + 16, playerY + 4, 4, 4);
            ctx.fillStyle = '#000';
            ctx.fillRect(playerX + 6, playerY + 6, 2, 2);
            ctx.fillRect(playerX + 18, playerY + 6, 2, 2);

            // Player smile
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(playerX + 12, playerY + 8, 3, 0, Math.PI);
            ctx.stroke();

            // Player jumping effect
            if (!player.onGround) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(playerX - 2, playerY + player.height, player.width + 4, 4);
            }

            // Draw jump particles
            player.jumpParticles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.fillRect(particle.x - 1, particle.y - 1, 3, 3);
            });

            // Draw rainbow explosion particles
            rainbowParticles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1.0; // Reset alpha

            // Draw balloon animals
            balloonAnimals.forEach(animal => {
                const bobY = Math.sin((Date.now() * 0.003) + animal.bobOffset) * 3;
                const alpha = Math.min(1, animal.life / 300); // Fade in first 5 seconds
                
                // Balloon body
                ctx.globalAlpha = alpha;
                ctx.fillStyle = animal.color;
                ctx.fillRect(animal.x - 8, animal.y + bobY - 8, 16, 12);
                
                // Balloon highlight
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(animal.x - 5, animal.y + bobY - 5, 4, 4);
                
                // Balloon string
                ctx.fillStyle = '#000';
                ctx.fillRect(animal.x - 1, animal.y + bobY + 4, 2, 12);
                
                // Animal emoji (using text rendering)
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(animal.animal, animal.x, animal.y + bobY + 2);
            });
            ctx.globalAlpha = 1.0; // Reset alpha
            ctx.textAlign = 'left'; // Reset alignment

            // Draw party kids
            partyKids.forEach(kid => {
                let bobY = Math.sin((Date.now() * 0.002) + kid.bobOffset) * 1; // Gentle bobbing
                if (kid.celebrating) {
                    bobY = -kid.jumpHeight; // Override bobbing with jumping during celebration
                }
                const kidX = kid.x;
                const kidY = kid.y + bobY;

                // Kid body gradient
                const kidGradient = ctx.createLinearGradient(kidX, kidY, kidX, kidY + kid.height);
                kidGradient.addColorStop(0, kid.color);
                kidGradient.addColorStop(1, '#888888');
                ctx.fillStyle = kidGradient;
                ctx.fillRect(kidX, kidY, kid.width, kid.height);
                
                // Kid outline
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                ctx.strokeRect(kidX, kidY, kid.width, kid.height);

                // Kid face
                ctx.fillStyle = '#FFE4B5';
                ctx.fillRect(kidX + 2, kidY + 2, kid.width - 4, 10);

                // Eyes
                ctx.fillStyle = '#FFF';
                ctx.fillRect(kidX + 3, kidY + 3, 3, 3);
                ctx.fillRect(kidX + kid.width - 6, kidY + 3, 3, 3);
                
                // Eye pupils based on direction
                ctx.fillStyle = '#000';
                if (kid.direction === 'right') {
                    ctx.fillRect(kidX + 4, kidY + 4, 2, 2);
                    ctx.fillRect(kidX + kid.width - 5, kidY + 4, 2, 2);
                } else {
                    ctx.fillRect(kidX + 3, kidY + 4, 2, 2);
                    ctx.fillRect(kidX + kid.width - 6, kidY + 4, 2, 2);
                }

                // Happy smile
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(kidX + kid.width/2, kidY + 7, 2, 0, Math.PI);
                ctx.stroke();
                
                // Simple chat bubble when talking
                if (kid.chatBubbleTime > 0) {
                    const bubbleX = kidX + kid.width + 5;
                    const bubbleY = kidY - 10;
                    
                    // Bubble background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(bubbleX, bubbleY, 20, 12);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(bubbleX, bubbleY, 20, 12);
                    
                    // Simple dots to represent talking
                    ctx.fillStyle = '#000';
                    ctx.fillRect(bubbleX + 4, bubbleY + 5, 2, 2);
                    ctx.fillRect(bubbleX + 9, bubbleY + 5, 2, 2);
                    ctx.fillRect(bubbleX + 14, bubbleY + 5, 2, 2);
                }
            });

            ctx.restore();

            // Draw party details in retro game font style (only when showing menu)
            if (showingMenu) {
                drawPartyDetails();
            }
        }

        // QR code image for credits screen
        let qrCodeImage = null;
        
        // Load QR code image
        function loadQRCode() {
            if (!qrCodeImage) {
                qrCodeImage = new Image();
                qrCodeImage.src = './qrcode.png';
            }
        }

        // Draw multi-screen menu system with authentic pixelated bitmap font
        function drawPartyDetails() {
            const menuData = getCurrentMenuData();
            const items = menuData.items;
            const title = menuData.title;

            // Calculate position - moved down to show EVAN BDAY blocks above
            const startY = canvas.height * 0.45; // 45% from top to leave space for game blocks
            const lineHeight = 22;
            const titleHeight = lineHeight + 8; // Extra space for title

            // Draw title first to calculate total height
            let totalItems = items.length + 2; // +2 for title and spacing
            let totalHeight = totalItems * lineHeight + 24;
            
            // Add extra height for QR code in credits screen
            if (currentMenuScreen === MENU_SCREENS.CREDITS) {
                totalHeight += 60; // Extra space for QR code image
            }

            // Draw background panel sized to ~40 characters for wider screens
            ctx.fillStyle = '#000080'; // Deep blue background like King's Quest
            const fontSize = Math.max(12, Math.min(16, canvas.width / 80));
            ctx.font = `${fontSize}px 'Press Start 2P', monospace`;
            const charWidth = ctx.measureText('M').width; // Use 'M' as character width reference
            const panelWidth = charWidth * 40; // 40 character widths for more content
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = startY - 8;
            
            ctx.fillRect(panelX, panelY, panelWidth, totalHeight);
            
            // Classic raised border effect
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelWidth, totalHeight);
            ctx.strokeStyle = '#808080';
            ctx.strokeRect(panelX + 2, panelY + 2, panelWidth - 4, totalHeight - 4);

            // Disable anti-aliasing for crisp pixels
            ctx.imageSmoothingEnabled = false;
            ctx.textBaseline = 'top';
            
            // Draw title
            const titleY = startY + 8;
            drawPixelText(title, canvas.width / 2, titleY, '#FFD700'); // Gold title
            
            // Draw menu items
            items.forEach((item, index) => {
                let y = startY + titleHeight + 8 + (index * lineHeight);
                
                // Special positioning for ESC - BACK in credits screen
                if (currentMenuScreen === MENU_SCREENS.CREDITS && item.text === 'ESC - BACK') {
                    y += 40; // Move ESC - BACK further down to avoid QR code
                }
                
                // Special handling for QR code in credits screen
                if (currentMenuScreen === MENU_SCREENS.CREDITS && item.text === '[QR CODE]') {
                    if (qrCodeImage && qrCodeImage.complete) {
                        // Draw QR code image
                        const qrSize = 80; // Size in pixels
                        const qrX = canvas.width / 2 - qrSize / 2;
                        const qrY = y - 10;
                        
                        ctx.imageSmoothingEnabled = false; // Keep pixels crisp
                        ctx.drawImage(qrCodeImage, qrX, qrY, qrSize, qrSize);
                        ctx.imageSmoothingEnabled = true;
                    } else {
                        // Fallback text if image not loaded
                        drawPixelText('[QR CODE LOADING...]', canvas.width / 2, y, '#808080');
                    }
                    return;
                }
                
                // Highlight selected menu item
                if (item.selectable && index === selectedMenuItem) {
                    // Draw selection highlight
                    ctx.fillStyle = '#FFD700';
                    const textWidth = ctx.measureText(item.text).width;
                    ctx.fillRect(canvas.width / 2 - textWidth / 2 - 8, y - 2, textWidth + 16, lineHeight - 4);
                    
                    // Draw selected text in blue
                    drawPixelText(item.text, canvas.width / 2, y, '#000080');
                } else {
                    // Different colors for different types of text
                    let color = '#FFFFFF'; // Default white
                    if (item.text.includes('ESC - BACK')) {
                        color = '#C0C0C0'; // Gray for back option
                    } else if (item.text.includes(':')) {
                        color = '#90EE90'; // Light green for stats/options with values
                    }
                    drawPixelText(item.text, canvas.width / 2, y, color);
                }
            });
            
            // Add navigation hint at bottom for non-main screens (except rsvp and credits)
            if (currentMenuScreen !== MENU_SCREENS.MAIN && currentMenuScreen !== MENU_SCREENS.RSVP && currentMenuScreen !== MENU_SCREENS.CREDITS) {
                const hintY = startY + totalHeight - 12;
                drawPixelText('ESC - BACK TO MAIN MENU', canvas.width / 2, hintY, '#808080');
            }
            
            // Re-enable smoothing for other elements
            ctx.imageSmoothingEnabled = true;
            ctx.textBaseline = 'alphabetic';
        }

        // Draw text with pixelated bitmap font effect
        function drawPixelText(text, centerX, y, color = '#FFFFFF') {
            const fontSize = Math.max(12, Math.min(16, canvas.width / 80)); // Back to smaller size
            
            // Use Press Start 2P for authentic retro game font
            ctx.font = `${fontSize}px 'Press Start 2P', monospace`;
            ctx.textAlign = 'center';
            
            // Draw with pixel-perfect positioning
            const x = Math.floor(centerX);
            const pixelY = Math.floor(y);
            
            // Use provided color or default to white
            ctx.fillStyle = color;
            ctx.fillText(text, x, pixelY);
            
            ctx.textAlign = 'left';
        }

        // Main game loop
        function gameLoop() {
            if (!showingMenu) {
                updatePlayer();
                updateRainbowParticles();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function startNewGame() {
            resetGame();
            gameStarted = true;
            showingMenu = false;
            incrementGamesPlayed(); // Track that a new game was started
        }

        function resetGame() {
            // Reset player
            player.x = 200;
            player.y = (LEVEL_HEIGHT - 4) * BLOCK_SIZE - player.height;
            player.velX = 0;
            player.velY = 0;
            player.onGround = false;
            player.jumpParticles = [];
            player.lastPinataHit = 0;
            player.attachedBalloon = null;
            player.balloonOffset = { x: 0, y: 0 };

            // Reset game systems
            rainbowParticles = [];
            balloonAnimals = [];
            lastBalloonTime = 0;
            pinataReplacementTime = 0; // Reset pinata replacement timer
            partyKids = [];
            pinataShake = {
                shaking: false,
                shakeTime: 0,
                shakeIntensity: 0
            };

            // Reset pinata
            window.pinataHits = 0;
            window.pinataDestroyed = false;

            // Recreate level
            initLevel();
        }

        // Add ESC key to show menu
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && gameStarted) {
                showingMenu = !showingMenu;
            }
        });

        // Initialize and start game
        initLevel();
        
        // Load statistics from localStorage
        loadStats();
        
        // Load QR code image
        loadQRCode();
        
        // Set player position on ground after level is created
        player.y = (LEVEL_HEIGHT - 4) * BLOCK_SIZE - player.height;
        
        // Setup touch controls
        setupTouchControls();
        
        // Register service worker for PWA with update detection
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                        
                        // Check for updates every time the page loads
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New content is available, reload page
                                    console.log('New content available, reloading...');
                                    window.location.reload();
                                }
                            });
                        });
                        
                        // Check for updates immediately
                        registration.update();
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
            
            // Listen for controllerchange to reload when new SW takes control
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('New service worker activated, reloading...');
                window.location.reload();
            });
        }
        
        gameLoop();

        // Placeholder for birthday message creation
        console.log("Birthday game initialized! Ready for birthday message blocks.");
    </script>
</body>
</html>